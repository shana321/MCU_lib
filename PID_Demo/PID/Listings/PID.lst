C51 COMPILER V9.00   PID                                                                   07/25/2018 10:31:22 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE PID
OBJECT MODULE PLACED IN .\Objects\PID.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE PID.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\PID.l
                    -st) TABS(2) OBJECT(.\Objects\PID.obj)

line level    source

   1          #include "PID.h"
   2          //½һPID󣬺Ӧ
   3          //mpid:PID
   4          //Input:ɼ
   5          //Output:
   6          //Setpoint:ֵ
   7          //Kp:ϵ
   8          //Ki:ֻϵ
   9          //Kd:΢ֻϵ
  10          //Pon:ģʽ
  11          //ControllerDirection:Ʒ
  12          //ʵдʱPIDʵǵKpKiKdsampletimeĸ
  13          /********************************
  14            ȣôȷڣϵͳƵƵ60%-80%֮ʱ(ϵͳͬ)
  15            eg:::һƱX,޳ʱ䣬¶ͣYôȡ¶0.6Y-0.8Y
             -ʱ䣬
  16            ЩϵͳԳ̶Ⱥܸݺı仯ʱҪﵽõĿЧһӼʱ
  17            
  18            ȷKp,KiKdһòKdͿкܺõĿЧKdһдͺϵͳ¶ȣ
  19            Kd¶Ȼûеֵʱͼٿ
  20            
  21            ȣKiKdó0ϼӴKpֱ񵴣Ϊ㣬
  22            Ȼ:Kiӣӵʼ񵴣ȡ80%-90%
  23            
  24            ϵͳͺKdֵʹõһγ͵ڶεķ41
  25            
  26            PIDɢʽ:OUT = kp * error + (ki * T)/Ti * error + kd *Td/T * error
  27          
  28            T:PIDڣTi:ʱ Td:΢ʱ error:ֵĲ    error:ۻerror 
  29          
  30            error:errorĲ 
  31            
  32            *********************************/
  33          void new_PID(PID_Class *mpid,PID_type* Input,PID_type* Output,PID_type* Setpoint,PID_type Kp,PID_type Ki,P
             -ID_type Kd,bool POn, bool ControllerDirection)
  34          {
  35   1          mpid->myOutput = Output;//myOutput
  36   1          mpid->myInput = Input;  //myInput
  37   1          mpid->mySetpoint = Setpoint;//mySetpoint
  38   1          mpid->inAuto = false;//inAuto ĬΪֶģʽ
  39   1      
  40   1          PID_SetOutputLimits(mpid,0,255);        //Ĭ޷255ǸarduinoƬõ
  41   1      
  42   1          mpid->SampleTime = 200;             //Ĭϼ0.2s200msҪPIDṩ1msļ200ŶӦ20
             -0msҲʵPIDmillis()
  43   1      
  44   1          PID_SetControllerDirection(mpid,ControllerDirection);//ÿƷ
  45   1                                                                //DIRECT  0  : PID 
  46   1                                                                //REVERSE  1 : PIDӣ  οյ䣬ӣյ
             -ǿԽ
  47   1          PID_SetTunings(mpid,Kp, Ki, Kd, POn); //PIDʽϵԼģʽǳģʽ
  48   1      
  49   1          mpid->lastTime = PIDmillis()-(mpid->SampleTime);  //ʼlastTimeʹһοֱӿʼPID
  50   1      }
C51 COMPILER V9.00   PID                                                                   07/25/2018 10:31:22 PAGE 2   

  51          //PIDʽϵԼģʽǳģʽ
  52          //mpid:PID
  53          //Kp:ϵ
  54          //Ki:ֻϵ
  55          //Kd:΢ֻϵ
  56          //POn:ģʽ  P_ON_M(0) Ƴ(ֳ߳С)
  57          //              P_ON_E(1) ģʽ(г)
  58          void PID_SetTunings(PID_Class *mpid,PID_type Kp, PID_type Ki, PID_type Kd, bool POn)
  59          {
  60   1          PID_type SampleTimeInSec = 0;
  61   1         if (Kp<0 || Ki<0 || Kd<0) return;
  62   1      
  63   1         //mpid->pOn = POn;
  64   1         mpid->pOnE = POn;
  65   1      
  66   1         mpid->dispKp = Kp; mpid->dispKi = Ki; mpid->dispKd = Kd;
  67   1      
  68   1         SampleTimeInSec = ((PID_type)mpid->SampleTime)/1000;
  69   1         mpid->kp = Kp;
  70   1         mpid->ki = Ki * SampleTimeInSec;
  71   1         mpid->kd = Kd / SampleTimeInSec;
  72   1      
  73   1        if(mpid->controllerDirection ==REVERSE)
  74   1         {
  75   2            mpid->kp = (0 - mpid->kp);
  76   2            mpid->ki = (0 - mpid->kp);
  77   2            mpid->kd = (0 - mpid->kp);
  78   2         }
  79   1      }
  80          //PID
  81          //mpid:PID
  82          //NewSampleTime:ΪٸʱƬPIDmillis()ֵ1Ӧ೤ʱ䣬һȡ1ms
  83          void PID_SetSampleTime(PID_Class *mpid,Timetick NewSampleTime)
  84          {
  85   1        PID_type SampleTimeInSec = 0;
  86   1         if (NewSampleTime > 0)
  87   1         {
  88   2            PID_type ratio  = (PID_type)NewSampleTime
  89   2                            / (PID_type)mpid->SampleTime;
  90   2            mpid->ki *= ratio;
  91   2            mpid->kd /= ratio;
  92   2            mpid->SampleTime = (Timetick)NewSampleTime;
  93   2           
  94   2         
  95   2      
  96   2         SampleTimeInSec = ((PID_type)mpid->SampleTime)/1000;
  97   2         mpid->kp = mpid->dispKp;
  98   2         mpid->ki = mpid->dispKi * SampleTimeInSec;
  99   2         mpid->kd = mpid->dispKd / SampleTimeInSec;//PIDϵ
 100   2           
 101   2         mpid->lastTime = PIDmillis()-(mpid->SampleTime);
 102   2         }
 103   1      }
 104          //PID޷С
 105          //mpid:PID
 106          //Min:Сֵ޷
 107          //Max:ֵ޷
 108          void PID_SetOutputLimits(PID_Class *mpid,PID_type Min, PID_type Max)
 109          {
 110   1         if(Min >= Max) return;
 111   1         mpid->outMin = Min;
 112   1         mpid->outMax = Max;
C51 COMPILER V9.00   PID                                                                   07/25/2018 10:31:22 PAGE 3   

 113   1      
 114   1         if(mpid->inAuto)
 115   1         {
 116   2           if(*(mpid->myOutput) > (mpid->outMax)) *(mpid->myOutput) = (mpid->outMax);
 117   2           else if(*(mpid->myOutput) < (mpid->outMin)) *(mpid->myOutput) = (mpid->outMin);
 118   2      
 119   2           if((mpid->outputSum) > mpid->outMax) (mpid->outputSum)= mpid->outMax;
 120   2           else if((mpid->outputSum) < mpid->outMin) mpid->outputSum= mpid->outMin;
 121   2         }
 122   1      }
 123          //PIDģʽԶֶ
 124          //mpid:PID
 125          //Mode: AUTOMATIC(1)ʱԶ
 126          //      MANUAL  (0) ֶ
 127          void PID_SetMode(PID_Class *mpid,bool Mode)
 128          {
 129   1          bool newAuto = (Mode == AUTOMATIC);
 130   1          if(newAuto && !(mpid->inAuto))
 131   1          {  
 132   2              PID_Initialize(mpid);
 133   2          }
 134   1          mpid->inAuto = newAuto;
 135   1      }
 136          //PIDʼ
 137          void PID_Initialize(PID_Class *mpid)
 138          {
 139   1         mpid->outputSum = *(mpid->myOutput);
 140   1         mpid->lastInput = *(mpid->myInput);
 141   1         if(mpid->outputSum > mpid->outMax) mpid->outputSum = mpid->outMax;
 142   1         else if(mpid->outputSum < mpid->outMin) mpid->outputSum = mpid->outMin;
 143   1      }
 144          //PIDƷ
 145          //Direction:  DIRECT  0  : PID 
 146          //            REVERSE  1 : PIDӣ  οյ䣬ӣյǿԽ
 147          void PID_SetControllerDirection(PID_Class *mpid,bool Direction)
 148          {
 149   1         if(mpid->inAuto && Direction !=mpid->controllerDirection)
 150   1         {
 151   2            mpid->kp = (0 - mpid->kp);
 152   2            mpid->ki = (0 - mpid->ki);
 153   2            mpid->kd = (0 - mpid->kd);
 154   2         }
 155   1         mpid->controllerDirection = Direction;
 156   1      }
 157          
 158          //PID㣬whileвϵ
 159          bool PID_Compute(PID_Class *mpid)
 160          {
 161   1         PID_type output = 0;
 162   1        Timetick now;         //洢кʱ
 163   1        Timetick timeChange;  //洢ϴִPIDν뺯ʱ
 164   1         if(!(mpid->inAuto))  //ֶģʽ¸úʧЧֱӷfalse
 165   1         {
 166   2           return false;
 167   2         }
 168   1         now = PIDmillis();   //ȡʱ
 169   1         timeChange = (now - mpid->lastTime); //õʱ
 170   1         if(timeChange>=(mpid->SampleTime)) //ʱڵڼʼPID
 171   1         {
 172   2            /*Compute all the working error variables*/
 173   2            PID_type input = *(mpid->myInput);  //ɼ
 174   2            PID_type error = *(mpid->mySetpoint) - input; //ɼֵֵƫ
C51 COMPILER V9.00   PID                                                                   07/25/2018 10:31:22 PAGE 4   

 175   2            PID_type dInput = (input - mpid->lastInput);  //βɼֵϴβɼֵĲerror
 176   2            mpid->outputSum+= (mpid->ki * error); //ֻ ڻֻʷйأoutputSumʷֵӰ
 177   2      
 178   2            /*Add Proportional on Measurement, if P_ON_M is specified*/
 179   2            if(!(mpid->pOnE)) (mpid->outputSum)-= (mpid->kp) * dInput;  //P_ON_MģʽƳ ֻڼ볬
             -
 180   2      
 181   2            if((mpid->outputSum) > (mpid->outMax)) (mpid->outputSum)= (mpid->outMax); //Ǵ޷ܵPID
             -ֹڹ󣩣ֵʱȡֵ
 182   2            else if((mpid->outputSum) < (mpid->outMin)) (mpid->outputSum)= (mpid->outMin);  //Сֵʱȡ
             -Сֵ
 183   2      
 184   2            /*Add Proportional on Error, if P_ON_E is specified*/
 185   2            if(mpid->pOnE) output = mpid->kp * error;                   //P_ON_Eģʽ(ģʽ)£outputֱӸֵڲ
             -
 186   2            else output = 0;                                            //P_ON_Mģʽ(Ƴ)£ڻֻм˱ڿƣ
             -outputֱӸֵ0
 187   2      
 188   2            /*Compute Rest of PID Output*/ //PIDʽʣkd΢ֻڣ 
 189   2            output += mpid->outputSum - mpid->kd * dInput;  //P_ON_Eģʽ£outputִ֮ǰkp
             -ڣ֣outputSum˻ֲ֣ʷֵйأ
 190   2                                                            //P_ON_Mģʽ£outputΪ0outputSumܱӰĻֲ֣Ҳǰ
             -
 191   2            if(output > mpid->outMax) output = mpid->outMax;  //ֵ޷
 192   2            else if(output < mpid->outMin) output = mpid->outMin; //Сֵ޷
 193   2            *(mpid->myOutput) = output; //洢output
 194   2      
 195   2            /*Remember some variables for next time*/
 196   2            mpid->lastInput = input;  //˴βɼֵԱ´error
 197   2            mpid->lastTime = now; //˴μϵʱ㣬Ա´жǷ˼
 198   2            return true;    //ϣtrue
 199   2         }
 200   1         else return false; //δڣֱӷfalse
 201   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2135    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----     110
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
